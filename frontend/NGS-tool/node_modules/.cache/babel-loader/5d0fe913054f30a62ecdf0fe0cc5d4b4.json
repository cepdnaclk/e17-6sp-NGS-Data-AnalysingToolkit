{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\n\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\n\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using XML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\n\nexports.encodeXML = getASCIIEncoder(inverseXML);\n\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\n\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\r\n * Encodes all entities and non-ASCII characters in the input.\r\n *\r\n * This includes characters that are valid ASCII characters in HTML documents.\r\n * For example `#` will be encoded as `&num;`. To get a more compact output,\r\n * consider using the `encodeNonAsciiHTML` function.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\n\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\r\n * documents using HTML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\n\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\n\nfunction getInverseObj(obj) {\n  return Object.keys(obj).sort().reduce(function (inverse, name) {\n    inverse[obj[name]] = \"&\" + name + \";\";\n    return inverse;\n  }, {});\n}\n\nfunction getInverseReplacer(inverse) {\n  var single = [];\n  var multiple = [];\n\n  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n    var k = _a[_i];\n\n    if (k.length === 1) {\n      // Add value to single array\n      single.push(\"\\\\\" + k);\n    } else {\n      // Add value to multiple array\n      multiple.push(k);\n    }\n  } // Add ranges to single characters.\n\n\n  single.sort();\n\n  for (var start = 0; start < single.length - 1; start++) {\n    // Find the end of a run of characters\n    var end = start;\n\n    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n      end += 1;\n    }\n\n    var count = 1 + end - start; // We want to replace at least three characters\n\n    if (count < 3) continue;\n    single.splice(start, count, single[start] + \"-\" + single[end]);\n  }\n\n  multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n  return new RegExp(multiple.join(\"|\"), \"g\");\n} // /[^\\0-\\x7F]/gu\n\n\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nfunction (str) {\n  return str.codePointAt(0);\n} : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\nfunction (c) {\n  return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;\n};\n\nfunction singleCharReplacer(c) {\n  return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + \";\";\n}\n\nfunction getInverse(inverse, re) {\n  return function (data) {\n    return data.replace(re, function (name) {\n      return inverse[name];\n    }).replace(reNonASCII, singleCharReplacer);\n  };\n}\n\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\r\n *\r\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\r\n * of reduced transportability.\r\n *\r\n * @param data String to escape.\r\n */\n\nfunction escape(data) {\n  return data.replace(reEscapeChars, singleCharReplacer);\n}\n\nexports.escape = escape;\n/**\r\n * Encodes all characters not valid in XML documents using numeric hexadecimal\r\n * reference (eg. `&#xfc;`).\r\n *\r\n * Note that the output will be character-set dependent.\r\n *\r\n * @param data String to escape.\r\n */\n\nfunction escapeUTF8(data) {\n  return data.replace(xmlReplacer, singleCharReplacer);\n}\n\nexports.escapeUTF8 = escapeUTF8;\n\nfunction getASCIIEncoder(obj) {\n  return function (data) {\n    return data.replace(reEscapeChars, function (c) {\n      return obj[c] || singleCharReplacer(c);\n    });\n  };\n}","map":{"version":3,"sources":["C:/Users/USER/Documents/6 sem/6s-proj/e17-co328-NGS-Data-AnalysingToolkit/frontend/NGS-tool/node_modules/react-html-parser/node_modules/dom-serializer/node_modules/entities/lib/encode.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","escapeUTF8","escape","encodeNonAsciiHTML","encodeHTML","encodeXML","xml_json_1","require","inverseXML","getInverseObj","default","xmlReplacer","getInverseReplacer","getASCIIEncoder","entities_json_1","inverseHTML","htmlReplacer","getInverse","obj","keys","sort","reduce","inverse","name","single","multiple","_i","_a","length","k","push","start","end","charCodeAt","count","splice","unshift","join","RegExp","reNonASCII","getCodePoint","String","prototype","codePointAt","str","c","singleCharReplacer","toString","toUpperCase","re","data","replace","reEscapeChars","source"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\r\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\r\nvar inverseXML = getInverseObj(xml_json_1.default);\r\nvar xmlReplacer = getInverseReplacer(inverseXML);\r\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using XML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\r\nexports.encodeXML = getASCIIEncoder(inverseXML);\r\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\r\nvar inverseHTML = getInverseObj(entities_json_1.default);\r\nvar htmlReplacer = getInverseReplacer(inverseHTML);\r\n/**\r\n * Encodes all entities and non-ASCII characters in the input.\r\n *\r\n * This includes characters that are valid ASCII characters in HTML documents.\r\n * For example `#` will be encoded as `&num;`. To get a more compact output,\r\n * consider using the `encodeNonAsciiHTML` function.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\r\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\r\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\r\n * documents using HTML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\r\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\r\nfunction getInverseObj(obj) {\r\n    return Object.keys(obj)\r\n        .sort()\r\n        .reduce(function (inverse, name) {\r\n        inverse[obj[name]] = \"&\" + name + \";\";\r\n        return inverse;\r\n    }, {});\r\n}\r\nfunction getInverseReplacer(inverse) {\r\n    var single = [];\r\n    var multiple = [];\r\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\r\n        var k = _a[_i];\r\n        if (k.length === 1) {\r\n            // Add value to single array\r\n            single.push(\"\\\\\" + k);\r\n        }\r\n        else {\r\n            // Add value to multiple array\r\n            multiple.push(k);\r\n        }\r\n    }\r\n    // Add ranges to single characters.\r\n    single.sort();\r\n    for (var start = 0; start < single.length - 1; start++) {\r\n        // Find the end of a run of characters\r\n        var end = start;\r\n        while (end < single.length - 1 &&\r\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\r\n            end += 1;\r\n        }\r\n        var count = 1 + end - start;\r\n        // We want to replace at least three characters\r\n        if (count < 3)\r\n            continue;\r\n        single.splice(start, count, single[start] + \"-\" + single[end]);\r\n    }\r\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\r\n    return new RegExp(multiple.join(\"|\"), \"g\");\r\n}\r\n// /[^\\0-\\x7F]/gu\r\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\r\nvar getCodePoint = \r\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\nString.prototype.codePointAt != null\r\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n        function (str) { return str.codePointAt(0); }\r\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n        function (c) {\r\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\r\n                c.charCodeAt(1) -\r\n                0xdc00 +\r\n                0x10000;\r\n        };\r\nfunction singleCharReplacer(c) {\r\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\r\n        .toString(16)\r\n        .toUpperCase() + \";\";\r\n}\r\nfunction getInverse(inverse, re) {\r\n    return function (data) {\r\n        return data\r\n            .replace(re, function (name) { return inverse[name]; })\r\n            .replace(reNonASCII, singleCharReplacer);\r\n    };\r\n}\r\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\r\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\r\n *\r\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\r\n * of reduced transportability.\r\n *\r\n * @param data String to escape.\r\n */\r\nfunction escape(data) {\r\n    return data.replace(reEscapeChars, singleCharReplacer);\r\n}\r\nexports.escape = escape;\r\n/**\r\n * Encodes all characters not valid in XML documents using numeric hexadecimal\r\n * reference (eg. `&#xfc;`).\r\n *\r\n * Note that the output will be character-set dependent.\r\n *\r\n * @param data String to escape.\r\n */\r\nfunction escapeUTF8(data) {\r\n    return data.replace(xmlReplacer, singleCharReplacer);\r\n}\r\nexports.escapeUTF8 = escapeUTF8;\r\nfunction getASCIIEncoder(obj) {\r\n    return function (data) {\r\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"script"}